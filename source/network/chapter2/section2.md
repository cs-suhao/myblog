## 2.2 Web和HTTP

超文本传输协议(HyperText Transfer Protocol)是Web的核心，HTTP由两个程序实现：客户端程序和服务端程序。客户端程序就是Web浏览器，而web服务器就是服务端程序。Web服务器用于存储Web对象，流行并且常用的是Apache和Microsoft Internet Information Server。

### 2.2.1 HTTP概况

HTTP使用TCP作为支撑运输的协议，连接过程如下：
1. 浏览器首先发起TCP连接。
2. TCP连接建立以后，浏览器通过套接字使得客户进程与TCP连接，服务器端也一样。
3. 浏览器发送HTTP请求报文，并从套接字接受HTTP响应报文。

HTTP是一个**无状态协议**，也就是说，HTTP服务器并不保存关于客户的任何信息，即使一个客户在短时间内多次请求同一个对象，服务器仍然会重新发送该对象。

### 2.2.2 持续连接和非持续连接

HTTP默认使用持续连接，但是可以经过设置使用非持续连接。

#### 2.2.2.1 非持续连接

**非持续连接**指每个请求/响应对是经一个单独的TCP连接发送。采用非持续连接的HTTP步骤如下，当我们请求一个HTML基本文件和10个JPEG文件：

1. 客户端在80端口向服务器发起TCP连接，客户端和服务端各有一个套接字与该连接关联。（80端口一般是服务器端的）
2. 客户端从套接字向服务端发送一个HTTP请求报文，报文中包含了路径名称。（HTTP请求报文会和TCP第三次握手的确认一起发送）
3. 服务器端进程从套接字接收该请求，从存储中检索出对象，在HTTP响应报文中封装对象，经套接字向客户端发送响应报文。
4. 服务端进程通知TCP断开TCP连接，直到TCP确认客户端收到完整响应报文才实际关闭。
5. 客户端接受HTTP响应报文，TCP连接关闭。
6. 客户端对每一个引用的JPEG文件重复前5个步骤。

上述过程耗费的时间为：**两个RTT+传输HTML文件的时间**。

值得注意的是，浏览器其实是可以进行并行TCP连接，默认方式下，大部分浏览器可以打开5-10个并行TCP连接。

#### 2.2.2.1 持续连接

**持续连接**指一段时间内的所有请求/响应对是经相同的TCP连接发送的。在采用持续连接的HTTP情况下，服务器在发送响应后保持该TCP连接打开，在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。

### 2.2.3 HTTP报文

#### 2.2.3.1 HTTP请求报文

请求报文的一个例子：
```
GET /somedir/page.html HTTP/1.1 //请求行：方法字段+URL字段+HTTP版本字段
Host: www.someschool.edu        //首部行：指明对象所在的主机
Connection: close               //首部行：告诉服务器发送完HTTP响应报文以后关闭该TCP连接
User-agent: Mozilla/5.0         //首部行：浏览器版本
Accept-lanuguage: fr            //首部行：语言
```
在HTTP请求报文的通用格式中，首部行中还有一个实体体，使用GET方法时实体体为空，而如果使用POST方法时，用户向搜索引擎请求一个特定内容的页面，该页面取决于POST字段的值。（当然，并不是一定使用POST方法才能生成请求）

#### 2.2.3.2 HTTP响应报文

响应报文的一个例子：
```
HTTP/1.1 200 OK                                 //状态行：版本+状态码+响应状态信息
Connection: close                               //首部行：告诉客户端发送完HTTP响应报文以后关闭该TCP连接
Date: True, 18 Aug 2015 15:44:04 GMT            //首部行：服务器产生和发送响应报文的时间与日期
Server: Apache/2.2.3 (CentOS)                   //首部行：服务器类型
Last-Modified: Tue, 18 Aug 2015 15:11:04 GMT    //首部行：指对象创建或最后修改的日期与时间
Content-Length: 6821                            //首部行
Content-Type: text/html                         //首部行

(data...)                                       //实体体  
```

一些常见的状态码和短语：
- **200 OK**: 请求成功，信息在返回的响应报文中。
- **301 Moved Permanently**:请求对象已被永久转移，新的URL在响应报文首部行中。
- **400 Bad Request**: 请求不被服务器理解。
- **404 Not Found**: 请求文档不在服务器中。
- **505 HTTP Version Not Supported**: 服务器不支持请求报文只用的HTTP协议版本。

总结一下，1XX是信息状态码，一般表示接受的请求正在处理，2XX是成功状态码，3XX是重定向状态码，需要进行附加操作完成请求，4XX是客户端错误状态码，表示服务器无法处理请求，5XX是服务器错误状态码，表示服务器处理请求出错。

### 2.2.4 Cookie

Cookie是允许站点对用户进行追踪的技术，其有4个组件：

1. HTTP响应报文的一个cookie首部行
2. HTTP请求报文的一个cookie首部行
3. 客户端保留的cookie文件，由浏览器管理
4. Web站点的后端数据库

cookie技术的步骤大致如下；用户第一次与某网站建立连接，服务器会为用户创建ID，然后在响应报文中加入该cookie ID，之后用户在发送请求报文时，会在首部行加入该网站的cookie值，这样服务器端就会将该用户在本网站的一些列操作都存储下来。可以用于身份识别。

### 2.2.5 Web缓存

**Web缓存器**也称为**代理服务器**，是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。

Web服务器通常由ISP购买并安装，也就是它并非真正的初始Web服务器，而是为了加快传输速度，先将曾经访问过的对象存储下载，有点类似于中间商，如果它有该对象，就会直接返回给客户，如果没有，会由代理服务器请求，然后拿到对象再响应客户。

这样会产生一个问题，就是Web缓存器中的对象有可能是陈旧的，因此用到了*条件GET*。里面有一个字段是`If-modified-since`，这是代理服务器会向初始Web服务器发送，确认该对象的最后修改时间，如果不变，那么就会返回确认，并且不附带实体体。