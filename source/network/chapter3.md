# Chapter 3. 传输层

## 3.1 概述

传输层的第一个关键功能是**将网络层的在两个端系统之间的交付服务扩展到运行在两个不同端系统上的应用层进程之间的交付服务**。传输层协议为不同主机的应用进程提供了**逻辑通信**，所谓的逻辑通信，就是让应用进程使用传输层的功能彼此发送报文，而无需考虑报文传输的具体细节。

传输层协议是在端系统中实现的，而不是在路由器中实现的。也就是说，在路由器中只作用与网络层字段，不会提取传输层字段。

因特网为应用层提供了两种传输层协议：
- UDP(用户数据报协议)：不可靠、无连接
- TCP(传输控制协议)：可靠、面向连接

同时，将主机间交付扩展到进程间交付被称为传输层的**多路复用**和**多路分解**。

## 3.2 多路复用和多路分解

- 多路分解：即将传输层报文段中的数据交付到正确的套接字的工作。
- 多路复用：即将不同套接字的数据块封装并传递到网络层的工作。

在传输层中，有源端口号和目的端口号两个字段，这两个字段就是用于识别哪个套接字。

### 3.2.1 无连接的多路复用和多路分解

在客户端，传输层协议自动并透明的分配端口号，而在服务器端则分配一个特定的端口号。两种`python`方式：
```python
clientSocket = socket(AF_INET, SOCK_DGRAM);

clientSocket.bind(('', 19157));
```

一个UDP套接字是由一个二元组全面标识，如果两个UDP报文具有不同的源IP和源端口，只要它们拥有相同的目的IP和目的端口，会被定位到相同的套接字：
```
<destination IP, destination port>
```

### 3.2.2 面向连接的多路复用和多路分解

一个TCP套接字是由一个四元组全面标识，如果两个具有不同源IP或源端口的TCP报文将被定向到两个不同的套接字上，除非这两个TCP报文是初始创建连接的报文。
```
<source IP, source port, destination IP, destination port>
```

大概的过程如下：
1. TCP客户端创建套接字，并向目的主机、目的端口发送TCP连接请求。
2. 服务器端在对应端口号等待连接，接收到请求报文后，服务器进程会创建一个新的套接字，然后将新的套接字和四元组绑定。TCP连接完成。
3. 服务器将会为每一个连接创建新的进程，每一个进程也将会与新的套接字（四元组）绑定。（当然现在高性能服务器会创建具有新套接字的新线程而非进程）。


## 3.3 UDP

UDP除了最基本的分解/复用和少量的差错检测外，没有增加其他功能。网络管理SNMP协议和DNS协议通常使用UDP协议。

### 3.3.1 UDP报文结构

UDP报文段结构如下所示：
```
0          15                31
source port | destination port
length      | check sum
Application data
```
- length：指示UDP报文段中的字节数（首部+数据），以字节为单位。

### 3.3.2 UDP校验和

UDP校验和用于确定当前UDP报文段，从源到目的移动时，其中的比特是否发生变化。

- 发送方：
    
    发送方的UDP对报文段中所有16比特字的和进行反码运算，求和时遇到的溢出会被回卷。而回卷运算就是进行16比特的加法运算时，如果进位到17位，那么要将第17位和后面16位进行加法运算。

    ```
    0110 0110 0110 0000
    0101 0101 0101 0101
    1000 1111 0000 1100
    ```
    进行加法运算，先进性前两个：
    ```
    0110 0110 0110 0000
    0101 0101 0101 0101
    -------------------
    1011 1011 1011 0101
    ```
    再进行加法，进位并回卷：
    ```
      1011 1011 1011 0101
      1000 1111 0000 1100
      -------------------
     10100 1010 1100 0001

      0100 1010 1100 0001
                        1
      -------------------
      0100 1010 1100 0010
    ```
    最后取反码：
    ```
    1011 0101 0011 1101
    ```

- 接收方

    接收方也做这样的操作，并进行差错检验。

其实有很多链路层协议时提供差错检验的，但是UDP首先提供，是因为：
1. 不能保证左右链路都提供差错检验；
2. 并且有可能报文段存储再某台路由器的内存中，引入了比特差错。

但是UDP虽然提供差错校验，但是没有纠错能力。

## 3.4 可靠数据传输原理

可靠数据传输协议(reliable data transfer protocol)是抽象的实现可靠数据传输的协议，接下来将一步一步设计这样一个传输协议：

1. rdt1.0

    我们首先考虑最简单的情况，也就是底层信道是完全可信，收发双方的速率完全相等。
    在这种情况下，rdt1.0收发双方都只需要一种状态，即发送/接受状态。
2. rdt2.0

    进一步，考虑传输过程中，数据包有比特位发生差错，但是数据包的顺序仍然一致。

    在这种情况是，基于这样的重传机制的协议称为**自动重传请求协议**，Automatic Repeat reQuest(ARQ)。

    这时需要考虑另一种问题，就是如果ACK或NAK分组报文出错了呢？

3. rdt3.0

    考虑传输过程中，可能发生比特错位和数据包丢失。

在rdt3.0中，已经能够实现可靠传输，利用自动重传、停止等待、序号和倒计数定时器。但是在实际应用中，停止等待产生的时间延时会很大，如果等待一个ACK到达才能够发送第二个数据包，整个链路的利用率会非常低、吞吐量会非常小。因此希望再次改进，把流水线的思想加入进去。

## 3.5 TCP

TCP被称为**面向连接**的，因为在一个进程开始与另一个进程发送数据前，两个进程必须先“握手”，并且连接双方都将初始化与TCP连接相关的TCP状态变量。

此外TCP提供的是全双工服务，如果A进程和B进程存在一条TCP连接，那么数据可以从进程A-进程B，也可以从进程B-进程A。

- 最大报文段长度(Maximum Segment Size)：一般根据最大传输单元来设置，最大传输单元是链路层的最大帧长度，保证MSS在加上TCP/IP首部长度(40字节)以后，不超过MTU值。由于以太网和PPP链路层协议都有1500字节的MTU值，所以一般MSS设置为1460.

### 3.5.1 TCP报文段

TCP的首部一般是20字节，比UDP多12字节。首部组成如下：

- **源端口号(16bit)**:

    和UDP一样。
- **目的端口号(16bit)**:

    和UDP一样，详情见3.4节。
- **序号(32bit)**:

    TCP把数据堪称无结构的、有序的字节流，因此序号是建立在传送的字节流基础上。TCP对数据流的每一个字节进行编号，首字节编号是0。
- **确认号(32bit)**:

    用于确认已经收到的字节流编号，填入的是主机A期望从主机B受到的下一个字节的序号。
- **首部长度(4bit)**：

    该字段指示了以32bit的字为单位的TCP首部长度，因为TCP包含选项字段，因此长度可变。而TCP首部长度最小为20字节。而4bit最大表示的数字是15，因此TCP首部长度最大范围应该是60字节。

    并且，这一个字段也称为“数据偏移”，因为指示了TCP的数据部分从第几个字节开始的（等同于首部长度）。
- **标志字段(6bit)**：
  - ACK：指示确认字段中的值是有效的
  - RST：
  - SYN：用于TCP建立连接
  - FIN：用于TCP拆除连接
  - PSH:指示接收方应该立即将数据交给上层
  - URG:只是报文段中存在被发送方标记为紧急的数据
- **接收窗口**:

    用于流量控制，指示接收方愿意接受的字节数量。
- **因特网校验和**：
- **紧急数据指针**：

### 3.5.2 TCP实现可靠传输

由于IP服务是不可靠的，因此传输过程中不保证**数据包按序到达**、**数据包不丢失**、**数据包数据完整**这几点。因此TCP需要保证数据流无损坏、无间隙、非冗余、按序到达。

TCP实现可靠传输和3.4节中描述的差不多，主要用以下几种协议：

1. 需要接收方确认和差错检测：**停止等待协议**+**自动重传协议(ARQ)**+**检验和**
2. 需要保证不乱序到达：字节流**序号**
3. 需要保证不丢包：**序号**+**ARQ**+**倒计时定时器**
4. 需要差错恢复：**滑动窗口**（回退N步+选择重传）
5. 需要更快传输：窗口+流水线
6. 需要流量控制：维护窗口长度




