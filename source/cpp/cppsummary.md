# C++面经

## 概览

### 1.C++代码执行的过程

 1. 预处理:处理宏定义、条件编译、#include头文件等
 2. 编译:进行词法和语法分析，确保没有语法错误的同时转换为汇编代码
 3. 汇编:将汇编代码转换成为机器指令
 4. 链接：将有关文件彼此相连接，也就是将一个文件中引用的符号同另一个文件的定义相关联，最后生成可执行文件

### 2.面向对象的三个基本特征是什么？各有什么作用和区别？

 1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
    - 优点：隔离变化、便于使用、提高重用性、提高安全性
    - 缺点：使用者不知道代码具体实现；封装太多影响效率

 2. 继承：一个对象直接使用另一个对象的属性和方法。
    - 作用：(1)减少重复的代码(2)继承是多态的前提(3)继承增加了类的耦合性
    - 缺点：
      - (1)继承在编译时刻就定义了，无法在运行时改变父类继承的实现。
      - (2)父类通常至少定义了子类的部分行为，父类的改变可能会影响子类的行为。
      - (3)如果继承下来的子类不适合解决新问题，那么父类必须重写或者替换，那么这种依赖就限制了灵活性和复用性。

 3. 多态：C++中有两种多态，分别是动多态（运行时多态）和静多态（编译期多态）。静多态主要通过模板来实现，宏也是实现多态的一种途径。动多态是通过虚函数实现的，即在基类中存在一些接口(一般为纯虚函数)，子类必须重载这些接口。动多态的函数调用机制是在执行期才能确定，所以是动态的。

### 3. C++和C最大的区别是什么？

可以从设计思想、语法以及内存管理这三方面来说。

1. **设计思想上：**
C++是面向对象的语言，而C是面向过程的结构化编程语言。
2. 语法上：
（1）C++具有封装、继承和多态三种特性 ；
（2）C++相比C，增加了许多类型安全的功能，比如强制类型转换；
（3）C++支持范式编程，比如模板类、函数模板等 。
3. 内存管理上：
C使用malloc/free，C++除此之外还使用new/delete。

### 4. 面向过程和面向对象的区别及优缺点

#### **面向过程：**

面向过程是一种自顶向下的编程，以**过程**为核心，强调事件的**流程、顺序**。

- **优点:** 性能比面向对象高，因为面向过程中的类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
- **缺点:** 没有面向对象易维护、易复用、易扩展。

#### **面向对象：**

面向对象是将事物高度抽象化。面向对象必须先建立抽象模型，之后直接使用模型就行了。以**对象**为核心，强调事件的**角色、主体**。

- **优点:** 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。面向对象技术具有程序结构清晰，自动生成程序框架，实现简单，可有效地减少程序的维护工作量，代码重用率高，软件开发效率高等优点。
  
- **缺点:** 因为类调用时需要实例化，开销比较大，比较消耗资源，性能比面向过程低。

### 5. C++是类型安全的语言吗

- 什么是类型安全？
    类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。

不是，简单的说因为它是支持强制类型转换的。但如果C++使用得当，它将远比C更有类型安全性。C#可以说是类型安全的。
相比于C，C++提供了一些新的机制保障类型安全：

1. 操作符new返回的指针类型严格与对象匹配，而不是void*
2. C中很多以void* 为参数的函数可以改写为C++模板函数，而模板是支持类型检查的
3. 引入const关键字代替 #define constants，他是有类型、作用域的，而#define constants这是简单的文本替换
4. 一些#define宏可被改写成为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
5. C++提供了dynamc_cast关键字，是的转换过程更加安全，因为dynamic_cast比static_cast涉及更多的类型检查；

### 6. C++的多态是如何实现的？

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1. 用virtual关键字声明的函数叫做**虚函数**，虚函数肯定是类的成员函数。
2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
4. 重写用虚函数来实现，结合动态绑定。一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为"虚"函数。**虚函数只能借助于指针或者引用来达到多态的效果。**
5. **纯虚函数**是虚函数再加上 = 0。纯虚函数：`virtual void fun()=0`。
6. 抽象类是指包括至少一个纯虚函数的类。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。则编译器要求在派生类中必须予以重写以实现多态性。纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

## 内存

### 1. C++中虚拟地址空间有哪些组成部分？其中每个部分存放什么？

由于每个进程都不能直接访问内核空间，而是通过系统调用间接进入内核，因此，所有的进程都共享内核空间。而每个进程都拥有各自的用户空间，各个进程之间不能相互访问彼此的用户空间（虚拟地址空间）。我们使用一个虚拟地址向进程提供一个连续的完整的地址使用，通过页表映射到物理内存的各个区域。

虚拟地址空间空间中：

1. 保留区（受保护的地址）
保留区即为受保护的地址，大小为128M，位于虚拟地址空间的最低部分，未赋予物理地址（不会与内存地址相对应，因此其不会放任何内容）。

2. 代码段
代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。

3. 数据段（.data段）
存放程序中已初始化的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。由于全局变量未初始化时，其默认值为0，因此值为0的全局变量位于.bbs段（不位于数据段）。

4. bbs段
该段用于存放未初始化的全局变量和静态局部变量，包括值为0的全局变量。 数据段和.bbs段又称为全局数据区，前者初始化，后者未初始化。
ELF段(属于**可执行程序部分**)包括：代码段、其它段（只读数据段和符号段等）、.data段（数据段）和.bbs段，。

5. 堆空间
new( )和malloc( )函数分配的空间就属于堆空间，用于内存空间的分配，其从下往上。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。

6. 内存映射段（共享库）
此处，内核将硬盘文件的内容直接映射到内存, 任何应用程序都可通过Linux的mmap()系统调用请求这种映射。内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。如C标准库函数（fread、fwrite、fopen等）和Linux系统I/O函数，它们都是动态库函数，其中C标准库函数都被封装在了/lib/libc.so库文件中，都是二进制文件。这些动态库函数都是与位置无关的代码，即每次被加载进入内存映射区时的位置都是不一样的，因此使用的是其本身的逻辑地址，经过变换成线性地址（虚拟地址），然后再映射到内存。而静态库不一样，由于静态库被链接到可执行文件中，因此其位于代码段，每次在地址空间中的位置都是固定的。

7. 栈空间
用于存放局部变量（非静态局部变量，C语言称为自动变量），分配存储空间时从上往下。栈和堆都是后进先出的数据结构。

8. 命令行参数
该段用于存放命令行参数的内容：argc和argv。

9. 环境变量
用于存放当前的环境变量，在Linux中用env命令可以查看其值。

### 2. C++中内存分配和内存管理的函数有哪些？

new和delete。保留了C的malloc和free。

### 3. new和malloc有什么区别？对应的析构操作是什么？

- **区别**
  - **属性：** new和delete是操作符，可以被重载。malloc和free是函数，可以重写。
  - **内存区域：** new从自由存储区分配内存，malloc从堆上分配内存。自由存储区是否就是堆，这取决于operator new 的实现细节（可能是）。
  - **自定义类型：** new在调用的时候先分配内存，再调用对象的构造函数，会生成对象，delete释放的时候调用析构函数；而malloc只分配内存，free仅回收内存，并没有构造和析构函数。
  - **返回类型：** new、delete 返回的是某种数据类型指针,类型严格与对象匹配，无须进行类型转换，故**new是类型安全型**的操作符；malloc、free 返回的是 void 指针，需要通过强制类型转换将void*指针转换成我们需要的类型。
  - **参数：** 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；使用malloc则需要显式地指出所需内存的尺寸
  - **分配失败：** new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL

- **底层实现**
  - malloc先申请大块内存作为堆区，然后将堆区分为多个内存块。
  - new 会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用构造函数（创建新对象->将构造函数的作用域赋值给这个新的对象、this指向新对象->执行构造语句（给对象赋予属性）->返回对象）

### 4. malloc申请的空间没有及时释放会导致哪些问题？

虽每个程序都包含一或多个进程运行，而每个进程都有自己的进程堆。程序中动态申请的空间如果没有手动释放，在程序运行结束，也就是所有进程消亡后，系统也会将进程中申请的所有的内存资源全部释放。但是如果一旦程序运行时间过程，或者程序占用内存过大，进程就会耗尽系统所有内存，最终造成**内存泄漏**。

### 5. 如果发生内存泄漏，该如何定位错误并解决？

1. 检查容器是否持续增长，如打印 `vec.size()`
2. 检查new和malloc申请的内存是否释放
3. 使用库
[C++内存泄漏问题定位案例](https://wenku.baidu.com/view/818441d44593daef5ef7ba0d4a7302768e996f04.html)

### 6. 堆栈溢出会导致什么问题？

递归过程的局部变量过多、递归深度过大，是造成系统栈溢出的原因。

一般后果：
堆栈溢出时会访问不存在的RAM空间，造成代码跑飞，这时无法得到溢出时的上下文数据，也无法对后续的程序修改提供有用信息。程序崩溃。

安全威胁：
堆栈溢出常见的攻击类型有：修改函数的返回地址，使其指向攻击代码，当函数调用结束时程序跳转到攻击者设定的地址而不是原先的地址，修改函数指针，长跳转缓冲区来找到一个可供溢出的缓冲区。蠕虫病毒，1988。

### 7. C++的浅拷贝和深拷贝有什么区别？

1. 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致**指针悬挂(野指针)** 现象，所以此时必须采用深拷贝。

2. 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，
从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

## 指针与引用

### 1. 指针和引用的区别？

1、**类型：** 指针是一个变量，存储的是变量(对象)的地址，引用是变量的别名
2、**初始化是否可以为空：** 指针可以为空，引用定义时必须初始化
3、**初始化后是否可以改变指向：** 指针在初始化之后可以改变指向同一个卡类型实体，引用在初始化之后不可在改变
4、**指向是否为空：** 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。因此可以说引用比指针安全。
5、**是否多级：** 指针可以有多级，引用只有一级
6、**sizeof大小：** sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
7、**内存：** 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间
8、**传参：** 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以
9、**自加1：** 引用自加即引用的实体增加1,指针自加即指针向后偏移一个类型的大小
10、**访问实体的方式**不同,指针需要显式解引用,引用编译器自己处理

### 2. C++中不同类型的指针能不能强制转换？

#### C++11强制类型转换

- **static_cast**
  用来进行比较“自然”和低风险的转换，比如整形和实数型、字符型之间互相转换。
  比C语言的类型转换：
    1) 更加安全；
    2) 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图

- **reinterpret_cast**
  用来进行各种不同类型的指针之间的转换、不同类型的引用之间转换、以及指针和能容纳得下指针的整数类型之间的转换。转换的时候，执行的是逐个比特拷贝的操作。

- **const_cast**
  用来进行去除const属性的转换。将const引用转换成同类型的非const引用，将const指针转换为同类型的非const指针时用它。

- **dynamic_cast**
  专门用于将多态基类的指针或引用，强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回NULL。
  不能用于将非多态基类的指针或引用，强制转换为派生类的指针或引用

### 3. C++中值传递和引用传递的区别？如果参数是指针，是哪一种传递？

**值传递：** 将实参的值传递给形参；形参有自己独立的存储空间。
**引用传递：** 引用并不分配独立的存储空间，它与目标变量共用内存空间。如果该引用不是用作函数的参数或者返回值，则必须提供该引用的初始值。使用引用传递可以通过形参的值直接改变实参的值，而使用值传递不可以。

参数是指针进行值传递，详见问题1(指针和引用的区别)

### 4. 智能指针有哪些？它们的应用场景是什么？

[智能指针实现原理以及用法](https://blog.csdn.net/sing_Hwang/article/details/86807216)

#### shared_ptr

- 每个shared_ptr都有一个关联的计数器，通常称为引用计数，一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象；shared_ptr的析构函数就会递减它所指的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。

- shared_ptr中是存在线程安全问题的，简单的来说当，B，C对象同时来引用A对象时候也许引用计数并不会加到3，而是2.所以考虑到线程安全问题时候，我们就要加锁

#### unique_ptr

- 一个unique_ptr拥有它所指向的对象。某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。

#### weak_ptr

- 弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。
- **循环引用**：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

### 5. 函数的返回值可以是unique_ptr吗？为什么？

可以，unique_ptr不能copy ，但是可以move。作为函数返回值，并不是生成了一个新的指针，只是生成了临时变量（右值）作为返回值。
以前没右值引用时只能拷贝, 现在可以move了, 不过上面代码在gcc或者vc上应该连move都不会产生, 应该被优化掉了。

### 6. C++的左值引用和右值引用有什么区别？

#### 左值引用

- 是常规引用，不能绑定到要转换的表达式、字面量或返回右值的表达式。
- 返回左值的表达式包括返回左值引用的函数及赋值、下标、解引用、**前置递增/递减**运算符。
- 左值引用的对象是持久的，不会马上销毁。

#### 右值引用

- 是只能绑定到右值的引用，通过&&获得，只能绑定到即将销毁的对象上（如字面量，临时计算结果，函数返回值，无名对象）。通过右值引用可以自由地移动绑定的资源。
- 返回右值的包括非引用类型的函数及算术、关系、位、**后置递增/递减**运算符。
- 右值引用的对象是短暂的，即将销毁的。

```cpp
int a = 2;
int &&r1 = 10; // 正确，右值引用可以绑定字面量
int &&r2 = a;  // 错误，带类型的变量不是右值
int &&r3 = std::move(a); // 正确，std::move能将左值转换成右值引用类型
int &&r4 = a * 10; // 正确，临时计算结果是右值
int &&r5 = *(new int(2)); // 错误， 不能绑定int型左值
int &&r6 = std::move(*new int(10)); // 正确，std::move能将左值转换成右值引用类型

int &rr1 = a;
int &rr2 = 1; // 错误
int &rr3 = std::max(10,20); // 错误
vector<int> vec = {1,2,3,4};
int &rr4 = vec[2];
int &rr5 = a * 10; // 错误
int &rr6 = *new int(10); 

```

### 关键字static、const、explicit、volatile

#### 1.static变量是什么时候初始化的？

类的static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。因此，static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。多个子类继承会共享同一份static变量，都可以对其进行修改。

#### 2.C++中全局静态变量和局部静态变量有什么区别？

#### 3.动态链接库中的全局变量同时被两个程序调用，会产生什么错误？

#### 4.const修饰的变量的区别

#### 5.const与宏的区别以及使用场景？

#### 6.explicit是什么？

#### 7.volatile是什么？