# 第二章 C++基础

## 2.1 语言基础

### new和malloc的区别，各自底层实现原理

* 区别
  * new是操作符，malloc是函数
  * new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数
  * new可以被重载；malloc不行
  * new分配内存更直接和安全
* 底层实现
  * malloc先申请大块内存作为堆区，然后将堆区分为多个内存块。
  * new 调用构造函数（创建新对象->将构造函数的作用域赋值给这个新的对象、this指向新对象->执行构造语句（给对象赋予属性）->返回对象）

### static关键字的作用

* 定义全局静态变量和局部静态变量，静态变量只能在本源文件中使用
* 定义静态函数，静态函数只能在本源文件中使用

**当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。**

#### 可执行程序包括BSS段、数据段、代码段

* BSS段存放的是未初始化的全局变量和静态变量
* 数据段包括初始化的数据和未初始化的数据（BSS）两部分

### 数组和指针的区别

* 数组：数组是用于储存多个相同类型数据的集合。 数组名是**首元素的地址**。
* 指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是**其它变量在内存中的地址**。在32位平台上，sizeof任意类型的指针都是4，在64位平台上是8

### 什么是函数指针？应用场景？

* 函数指针是**指向函数的指针**
* **应用场景：** 回调callback。在别人的库里调用我们定义的函数。如`sort(vec.begin(),vec.end(),com)`。`com`就是我们定义的比较函数。我们调用别人提供的API(应用程序接口)函数：call.

### 静态变量什么时候初始化？

#### 参考回答

* C语言的全局和静态变量：初始化发生在任何代码执行之前，属于编译期初始化。
* 而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

#### 解析

* **作用域：** C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域
  * 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。
  * 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束
  * 类静态成员变量：类作用域
* **所在空间：** 都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值
* **生命周期：** 静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存
  
### 说说静态局部变量，全局变量，局部变量的特点，以及使用场景

首先从**作用域**考虑：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。

* **全局变量：** 全局作用域，可以通过extern作用于其他非定义的源文件。

* **静态全局变量 ：** 全局作用域+文件作用域，所以无法在其他文件中使用。

* **局部变量**：局部作用域，比如函数的参数，函数内的局部变量等等。

* **静态局部变量：**  局部作用域，只被初始化一次，直到程序结束。

从**所在空间**考虑：除了**局部变量在栈上**外，**其他都在静态存储区**。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

**生命周期：** 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。

### 说说内联函数和函数的区别，内联函数的作用

#### 内联函数和函数的区别

* 内联函数比普通函数多了**关键字inline**
* 内联函数**避免了函数调用的开销**；普通函数有调用的开销
* 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数**不需要寻址**。

* 内联函数有一定的限制，内联函数体**要求代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。

#### 内联函数的作用

* 内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。

在使用内联函数时，应注意如下几点：

在内联函数内不允许用循环语句和开关语句。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。

内联函数的定义必须出现在内联函数第一次被调用之前。

### 说说内联函数和宏函数的区别

* **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而**内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。

* 宏函数是在预编译的时候把所有的宏名用宏体来替换，简单的说就是**字符串替换** ；而内联函数则是在编译的时候进行**代码插入**，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率

* **宏定义是没有类型检查**的，无论对还是错都是直接替换；而**内联函数在编译的时候会进行类型的检查**，内联函数满足函数的性质，比如有返回值、参数列表等

### nullptr调用成员函数可以吗？为什么？

* 能。因为在**编译时对象就绑定了函数地址**，和指针空不空没关系。

### 说说什么是野指针，怎么产生的，如何避免？

**概念：** 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

**产生原因：** 释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。

**避免办法：**
（1）初始化置NULL
（2）申请内存后判空 `assert(p != NULL); //判空，防错设计,命令assert(NULL!=p)的逻辑值为假时，程序终止运行，并提示错误,作用是定位错误而非排除`
（3）指针释放后置NULL
（4）使用智能指针

### 使用指针需要注意什么？

  （1）初始化置NULL
  （2）用malloc或new申请内存之后判空
  （3）指针释放后置NULL
  （4）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
  （5）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作
  （6）动态内存的申请与释放必须配对，防止内存泄漏

### const和define的区别

const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

* const生效于编译的阶段；define生效于预处理阶段。
* const定义的常量，在C语言中是存储在内存中、**需要额外的内存空间**的；define定义的常量，运行时是**直接的操作数**，并不会存放在内存中。
* const定义的常量是带类型的；define定义的常量不带类型。因此**define定义的常量不利于类型检查**。

### 简述C++有几种传值方式，之间的区别是什么

#### 值传递、引用传递、指针传递

* 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；

* 引用传递：形参在函数体内值发生变化，会影响实参的值；

* 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

### 简述const（星号）和（星号）const的区别

* const*是常量指针，*const 是指针常量

```cpp
 //const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变`
```

### 说说`const int *a, int const *a, const int a, int *const a, const int *const a`分别是什么，有什么特点

```cpp
 const int a;     //指的是a是一个常量，不允许修改。
 const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
 int const *a;    //同`const int *a;`
 int *const a;    //a指针所指向的内存地址不变，即a不变
 const int *const a;   //都不变，即（*a）不变，a也不变
```

## 2.2 C++ 内存

### 简述一下堆和栈的区别

* **空间分配不同**。堆是由程序员分配释放，栈是由操作系统自动分配释放，存放函数的参数值，局部变量的值等
* **缓存方式不同**。堆是在二级缓存中，释放慢。栈是在一级缓存中，调用结束释放。
* **数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。

### 简述C++的内存管理

内存分配方式：
在C++中，内存分成5个区，他们分别是**堆、栈、自由存储区、全局/静态存储区和常量存储区**。

* 栈，在执行函数时，函数内**局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
* 堆，就是那些由new分配的内存块，一般一个new就要对应一个delete。
* 自由存储区，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。
  *(自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。基本上，所有的C++编译器默认使用堆来实现自由存储)*
* 全局/静态存储区，**全局变量和静态变量** 被分配到同一块内存中
* 常量存储区，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。

### 常见的内存错误及其对策

* （1）内存分配未成功，却使用了它。
* （2）内存分配虽然成功，但是尚未初始化就引用它。
* （3）内存分配成功并且已经初始化，但操作越过了内存的边界。
* （4）忘记了释放内存，造成内存泄露。
* （5）释放了内存却继续使用它。

*内存泄漏的堆积最终会导致内存溢出。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。*
*内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序*
**对策：**
（1）用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
（2）定义指针时，先初始化为NULL。
（3）不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
（4）避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作
（5）动态内存的申请与释放必须配对，防止内存泄漏
（6）用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”
（7）使用智能指针。

### 什么是内存泄漏

申请了一块内存空间，使用完毕后没有释放掉。

 1. new和malloc申请资源使用后，没有用delete和free释放；
 2. 子类继承父类时，父类析构函数不是虚函数。
 3. Windows句柄资源使用后没有释放。

### malloc和局部变量分配在堆还是栈？

 malloc是在堆上分配内存，需要程序员自己回收内存；
 局部变量是在栈中分配内存，超过作用域就自动回收

### 一个程序有哪些部分？

   ![1](./c++/程序组成.png)
 从低地址到高地址，一个程序由**代码段、数据段、BSS段、堆、共享区、栈**等组成。

* 数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。

* 代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

* BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。未初始化的或者初始化为0的全局变量和静态变量。

可执行程序在运行时又会多出两个区域：堆区和栈区。

* 堆区：动态申请内存用。堆从低地址向高地址增长。malloc、new

* 栈区：存储**局部变量、函数参数值**。栈从高地址向低地址增长。是一块连续的空间。

* 最后还有一个共享区，位于堆和栈之间。

## 2.3面向对象（一）

### 简述一下什么是面向对象

面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

### 面向过程和面向对象的区别

* 面向过程：根据业务逻辑从上到下写代码
* 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程

### 简述一下面向对象的三大特征： 封装、继承、多态

* **封装：** 将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。
  
* **继承：** 可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
* ![106](./c++/三种继承.png)
  
* **多态：** 用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。

### 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限

类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。

public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。

protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

### 简述一下 C++ 的重载和重写，以及它们的区别

* **重写：是指派生类中存在重新定义的函数。** 其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。**只有函数体不同（花括号内）**，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

  ```cpp
  #include<bits/stdc++.h>  using namespace std;  
  class A { 
    public:  virtual void fun()  {   cout << "A";  } 
    }; 
  class B :public A { 
    public:  virtual void fun()  {   cout << "B";  } 
    }; 
    
    int main(void) {  
    //对象类型是派生类，所以输出派生类的函数
    A* a = new B();  
    a->fun();
    //输出B，A类中的fun在B类中重写 
    }
  ```

* **重载:** 我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了**用一个函数名定义多个函数，也就是所谓的函数重载**。**函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。**

```cpp
#include<bits/stdc++.h>  
using namespace std;  
class A {
    void fun() {};  
    void fun(int i) {};  
    void fun(int i, int j) {};     
    void fun1(int i,int j){}; 
    };
```

### c++的重载和重写是如何实现的

* c++的重载实现
C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。
C++定义同名重载函数：

```cpp
#include<iostream> using namespace std; 
  int func(int a,double b) {
      return ((a)+(b)); 
      } 
  int func(double a,float b) {
      return ((a)+(b)); 
      } 
  int func(float a,int b) {
      return ((a)+(b)); 
      } 
  int main() {  
      return 0; 
      }
```

### c++的重写实现

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1. 用virtual关键字申明的函数叫做**虚函数**，虚函数肯定是类的成员函数。
2. 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。
4. 重写用虚函数来实现，结合动态绑定。一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为"虚"函数。**虚函数只能借助于指针或者引用来达到多态的效果。**
5. **纯虚函数**是虚函数再加上 = 0。纯虚函数：`virtual void fun()=0`。
6. 抽象类是指包括至少一个纯虚函数的类。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。则编译器要求在派生类中必须予以重写以实现多态性。纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

### 说说构造函数有几种，分别什么作用

#### 默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数

* 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。

```cpp
class Student {
   public:  
   //默认构造函数  
   Student(){
      num=1001;        
      age=18;      
    }  
    //初始化构造函数  
    Student(int n,int a):num(n),age(a){} private:  
    int num;  
    int age; 
}; 
    
int main() {  
  //用默认构造函数初始化对象S1  
  Student s1;  
  //用初始化构造函数初始化对象S2  
  Student s2(1002,18);  
  return 0; 
}
```

* 拷贝构造函数
  
```cpp
#include "stdafx.h" 
#include "iostream.h"  
class Test {     
  int i;     
  int *p; 
  public:     
  Test(int ai,int value){         
    i = ai;         
    p = new int(value);     
  }     
  ~Test(){
    delete p;     
  }     
  Test(const Test& t){         
    this->i = t.i;         
    this->p = new int(*t.p);     
  }
}; 
  //复制构造函数用于复制本类的对象 
  int main(int argc, char* argv[]) {     
    //初始化构造
    Test t1(1,2);     
    Test t2(t1);
    //将对象t1复制给t2。注意拷贝（复制）和赋值的概念不同 
    return 0; 
    }
```

### 只定义析构函数，会自动生成哪些构造函数

* 只定义了析构函数,编译器将自动为我们生成**拷贝构造函数和默认构造函数**.
* 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。
* 有了有参的构造了，编译器就不提供默认的构造函数。
* 赋值构造函数默认实现的是值拷贝（浅拷贝）。如果一个类定义了析构函数，那么它要定义自己的拷贝构造函数和默认构造函数(否则赋值操作会让同一个类被指向两次，就会被析构两次)

```cpp
class Student { public:  
  //默认构造函数  
  Student(){     
    num=1001;        
    age=18;      
    }  
  //初始化构造函数  
  Student(int n,int a):num(n),age(a){} 
  private:  
    int num;  
    int age; 
}; 
int main() {  
  //用默认构造函数初始化对象S1  
  Student s1;  
  //用初始化构造函数初始化对象S2  
  Student s2(1002,18);  
  return 0; 
  }
```

### 一个类，默认会生成哪些函数

定义一个空类：`class Empty{};`

* 无参的构造函数：在定义类的对象的时候，完成对象的初始化工作 `Empty(){}`
* 拷贝构造函数：拷贝构造函数用于复制本类的对象`Empty(const Empty& copy){}`
* 赋值运算符`Empty& operator = (const Empty& copy){}`
* 析构函数（非虚）`~Empty(){}`

### 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序

* 父类构造函数–>成员类对象构造函数–>自身构造函数
* 其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。
* 析构顺序和构造顺序相反。

### 简述下向上转型和向下转型

* 子类转换为父类：向上转型，使用`dynamic_cast<type_id>(expression)`，这种转换相对来说比较安全不会有数据的丢失；
* 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存

### 简述下深拷贝和浅拷贝，如何实现深拷贝

* **浅拷贝**：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说**源对象和目标对象共用一份实体，只是所引用的变量名不同**，地址其实还是相同的。如果没有要定义自己的拷贝构造函数和默认构造函数，可能会析构两次同一个对象，也就是同一个内存释放两次，发生错误。

* **深拷贝**，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了**不同的内存位置。并且里面的内容是一样**的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。

* **深拷贝的实现：**
  * 深拷贝的拷贝构造函数
  * 赋值运算符的重载传统实现：先释放旧空间->开辟和原空间一样大的新内存->将原空间的内容赋值给新内存。解决了我们的指针悬挂问题，通过不断的开空间让不同的指针指向不同的内存，以防止同一块内存被释放两次的问题

### 简述一下 C++ 中的多态

由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：

* **静态多态：** 编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。（概念：函数重载）

* **动态多态：** 其实要实现动态多态，需要几个条件——即动态绑定条件：

  * 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
  * 通过基类类型的指针或引用来调用虚函数。
  * 概念：重写——也就是基类中有一个虚函数，而在派生类中也要重写一个原型（返回值、名字、参数）都相同的虚函数。不过协变例外。协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。

## 2.4 面向对象（二）

## 2.5 STL

### STL的组成部分

STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。

* 容器(Container)
  * 是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。

* 算法（Algorithm）
  * 是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

* 迭代器（Iterator）
  * 提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;

* 仿函数（Function object）
  * 仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。

* 适配器（Adaptor）
  * 简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。

* 内存分配器
  * 为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。
  容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：

### 请说说 STL 中常见的容器，并介绍一下实现原理

#### 顺序容器

* 容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：

（1）vector

* 动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。

（2）deque

* 双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

（3）list

* 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

#### 关联式容器

 元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。

 (1) set/multiset

* set 即集合。set中不允许相同元素，multiset中允许存在相同元素。

（2）map/multimap

* map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。

#### 容器适配器

  封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：

（1）stack

* 栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。

（2）queue

* 队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。

（3）priority_queue

* 优先级队列。内部维持某种有序，实际维护的是一个二叉堆实现，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。默认less，小于比较，越大优先级越大。

## 2.6 新特性（一）

## 2.7 新特性（二）
