# Chapter 2 线程管理

## 2.1 线程的基本操作

### 2.1.1 启动线程

线程在`std::thread`对象创建时启动，通常使用的是无参数返回的函数。这种函数在执行完毕，线程也就结束了。而在一些情况下，任务函数对象需要通过某种通讯机制进行参数的传递，或者执行一系列独立操作，通过通讯机制传递信号让线程停止。

简单来说，使用C++线程库启动线程，就是构造`std::thread`对象，需要包含头文件`<thread>`，`std::thread`可以用可调用类型构造，将带有函数调用符类型的实例传入类中，替换默认的构造函数。有以下几个方法:

- 方法一：传入函数对象

```cpp
class background_task
{
public:
  void operator()() const // 1
  {
    do_something();
    do_something_else();
  }
};
background_task f;
std::thread my_thread(f);
```
在这里，函数对象被复制到`std::thread`对象内部，函数对象的执行和调用都在线程的内存空间中进行。
注释：
1. `void operator()() const`中前一个`()`是调用符号，后一个是传参列表，这里是空。

需要注意的是，当把函数对象传入到线程构造函数中，需要避免”语法解析“。

- 方法二：传入lambda表达式
  
```cpp

std::thread my_thread([]{
  do_something();
  do_something_else();
});

```

- 方法三：传入函数指针和参数

```cpp
void f(int i);
std::thread(f, 3);
```


如果传递了一个临时变量，而不是命名变量，C++编译器会将其解析为函数声明，而非类型对象。例子如下：

```cpp
std::thread my_thread(background_task());
```
这句相当于声明了一个`my_thread`的函数，该函数带有一个参数（函数指针指向没有参数并返回background_task对象的函数），返回一个`std::thread`对象的函数，而非启动一个线程。

当启动线程后，需要明确等待线程结束还是自主运行，这两个分别对应着：`join()`和`detach()`。在`std::thread`对象销毁前没有做出决定，程序就会终止，也就是`std::thread`的析构函数会调用`std::terminate()`。

如果不等待线程，就必须保证线程结束前，可访问的数据具有有效性。处理这种情况的常规方法：使线程函数的功能齐全，将数据复制到线程中，而非复制到共享数据中。如果使用一个可调用的对象作为线程函数，这个对象就会复制到线程中，而后原始对象就会立即销毁。


### 2.1.2 等待线程完成


### 2.1.3 特殊情况下的等待


