# Chapter 3 线程间共享数据

## 3.1 共享数据带来的问题

当一个或多个线程需要修改共享数据的情况下，就会产生许多问题。可以用双链表的更新过程来说明这个共享数据的问题。

双链表中每一个节点都有一个指针指向下一个节点（后指针），一个指针指向前一个节点（前指针）。当我们从列表中删除一个节点的时候，其前后节点的指针就需要更新，更新的步骤如下：
1. 找到要删除的节点N
2. 更新前一个节点指向N的指针，让这个指针指向N的下一个节点
3. 更新后一个节点指向N的指针，让这个指针指向N的前一个节点
4. 删除节点N

![双链表更新节点过程](image/chapter3/3-1.png)

在过程2和3的时候，整个列表的顺序是错乱的，属于中间未稳定的状态。在这时候，如果有线程对该列表进行访问，就会产生非常严重的后果，某一个线程可能刚好访问到要删除的节点N，而其他线程如果按照顺序访问，就会跳过节点N，如果这时候某一个线程再次尝试删除相邻节点，那么这个双链表就断开了，对于整个数据结构产生永久性的损坏。

### 3.1.1 条件竞争

并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，如果对于系统的不变量不会造成破坏，这就是一种良性竞争，因为谁先谁后并不会产生严重后果。而如果造成不变量破坏，才会产生竞争条件，也就是双向链表的例子，这里就是我们需要避免的恶性竞争条件。

### 3.1.2 避免恶性竞争条件

解决恶性竞争条件，有几种选择：
- 对数据结构采用某种保护机制
- 对于数据结构和不变量的设计进行修改，保证每一个不变量保持稳定的状态，也就是所谓的无锁编程
- 使用事务的方式处理，参照GitHub提交代码的思想，在push之前如果有改变必须先pull才能提交


## 3.2 互斥量

和操作系统中互斥量的思想一致，在访问共享数据前，将数据锁住，在访问结束，再将数据解锁。其他线程必须等待前线程解锁后才能进行访问。但是和操作系统中提出的问题一致，该方法可能会造成死锁。

**死锁**的概念就是，线程A和线程B需要同时拥有两个资源a和b才能进行下一步，然后A锁住a，B锁住b，两个线程都在死等对方的资源，又不会释放拥有的资源，而导致循环等待。

### 3.2.1 C++中的互斥量

C++中通过`std::mutex`创建互斥量实例，可以通过lock()和unlock()上锁和解锁。但是实践中，C++标准库提供了一个RAll语法的模板类`std::lock_guard`，在构造时能提供已上锁的互斥量，在析构的时候进行解锁，从而保证一个已锁互斥量能够被正确解锁。

