# Chapter 1. 你好，并发世界

## 1.1 何谓并发

### 1.1.1 计算机的并发

计算机的并发指的是单个系统中同时执行多个独立的任务。在拥有多个处理器单元的机器中，能够并行执行多个任务，是真正的并发，也可以称为“硬件并发”。而在只有单核的处理器中，是通过任务切换来实现一种“并发的假象”，这两种的区别如下图：
![真并发vs任务切换](image/chapter1/1-1.png)
其中单核机器做任务切换时，红绿块中有一个灰色块，这代表切换任务的开销，因为在进行任务切换时，操作系统必须保存当前任务CPU的状态和指令指针，并计算需要切换到哪个任务，再将切换的任务加载。

但是处理器核心再多，也有比“可并行最大任务数”还要多的任务需要执行，所以任务切换在这些情况下任然是适用的。例如计算机会有很多后台程序，并且在运行后台程序的同时，我们还会同时运行编译器、浏览器等。

下图显示了四个任务在两个核心之间的切换，图中任务块的大小是理想情况，实际中受多因素影响，任务分割会不均匀，调度也会不规则。
![四任务在两核心中切换](image/chapter1/1-2.png)

### 1.1.2 并发的方式

并发的两种基本途径是：

1. 每个进程只要一个线程，这样的并发称为**多进程并发**。（每个开发者拥有自己的办公室）
2. 每个进程有多个线程，这样的并发称为**多线程并发**。（一个办公室有多个开发者）

- **多进程并发**

这种方式中，将应用程序分为独立的进程同时运行。独立的进程可以通过进程间的通信渠道传递讯息（信号、套接字、文件、管道等），因为操作系统需要对进程进行保护，因此进程间的通信比较复杂，会有速度慢、开销大的缺点。

![多进程并发](image/chapter1/1-3.png)

但是多进程并发也有优点，由于操作系统在进程间提供了更高级的保护和通信机制，所以并发代码更加安全，同时在远程连结的场景下，在多机器运行独立进程是一个优势。

- **多线程并发**

线程可以称为轻量级的进程，每个线程互相独立运行，并且在不同的指令序列中运行。不同的是，进程中的所有线程可以共享地址空间，并访问大部分数据，这里全局变量依然是全局的，指针、对象的引用或数据可以在线程之间传递。下图显示了一个进程中的两个线程正在通过共享内存进行通信：

![并发线程通信](image/chapter1/1-4.png)

多线程的开销远远小于多进程，但是需要对于进程间通信做大量工作。


## 1.2 为什么使用并发

### 1.2.1 分离关注点
编写软件时，分离关注点是一个好办法。通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能。可以用这样一个例子理解：

假设一个DVD播放程序，这样的程序应该有两个功能：
1. 从光盘中读出数据，对图像和声音进行解码，之后把解码的信号输出至视频、音频硬件中处理。
2. 接受来自用户的输入，当用户点击暂停、退出时执行相应的操作。

当应用是单线程时，应用需要在回放期间定期检查用户的输入，这就需要把“DVD播放”和“用户界面”代码放在一起，而如果使用多线程来分离这些关注点，一个线程处理“用户界面”，另一个进行“DVD播放”。所以，通常独立的线程用来执行哪些必须在后台持续运行的任务。

### 1.2.2 性能

重核系统到今天也只在超级计算机、大型机、大型服务器中看到。而多核计算机、多核嵌入式设备现在越来越普遍，它们计算能力提高不是使单一任务运行更快，而是并行多个任务。

有两种利用并发来提高性能的方式：
1. 任务并行（task parallelism）：将一个单任务分成几部分并行运行，从而降低总运行时间。这是一个复杂过程，因为各部分之间可能存在依赖。
2. 数据并行（data parallelism）：每个线程在不同的数据块上执行相同的操作。

### 1.2.3 什么时候不适用并发

- **收益比不上成本。**
  
  使用并发的代码在很多情况下难以理解，因此编写和维护多线程代码会产生脑力成本，而增加的复杂性也可能会引起更多的错误。除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消为确保正确开发所需的额外时间，以及维护代码的额外成本；否则，勿用并发。

- 性能增益小于预期
  
  多线程切换是存在固有开销的。

- 线程资源有限
  
  线程资源有限，每一个线程都需要独立堆栈，如果运行太多堆栈会耗尽进程的可用内存和地址空间。


## 1.3 C++的并发和多线程

### 1.3.1 C++多线程历史

- C++98不支持（缺少编译器扩展的情况下）
- C++11中的标准库扩展，和Boost库类似
- C++14和C++17对于并发和并行支持更多

### 1.3.2 C++线程库的效率

为了效率，C++整合了一些底层工具。区别就是在于使用高级工具和使用低级工具的开销差，这个开销差就是抽象代价(abstraction penalty)。也就是说，底层工具面向和硬件的开发者，提供了原子操作库，可以直接控制单个位、字节、内部线程间的同步。

而高级工具使得编写多线程代码更加简单，因为有额外的代码需要执行，这些工具会带来性能开销。

## 1.4 开始入门

### 1.4.1 HelloWorld

一个简单的独立线程程序：

```cpp
#include <iostream>
#include <thread>

void hello() // 1
{
    std::cout << "Hello Concurrent World!\n";
}

int main()
{
    std::thread t(hello); // 2
    t.join(); // 3
}
```
注意cmake的编写如下，Linux下如果不加这几句会报错：

```cmake
cmake_minimum_required(VERSION 3.10)
 project(CppConcurrency)
 set(CMAKE_CXX_FLAGS -pthread)
 message(STATUS "CMAKE_CXX_FLAGS = ${CMAKE_CXX_FLAGS}")
 add_executable(helloworld helloworld.cpp)
```
注释如下：
1. 每一个线程都必须选择一个执行单元，新线程的执行从这里开始，对于应用程序而言，初始线程就是`main()`，而对于其他线程，可以在`std::thread`对象的构造函数中指定。
2. 与直接main输出和调用hello()不同，这里启动了一个全新的线程来实现，将线程数量一分为二，初始线程始于`main()`，而新线程始于`hello()`。
3. 新的线程启动之后，初始线程继续执行，如果不等待新线程结束，就运行到`main()`函数结束，这可能发生在新线程运行之前，因此调用`join()`让创建线程等待`std::thread`对象创建的线程。

