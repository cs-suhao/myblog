# 剑指Offer

## 2.3 数据结构

### 2.3.1 数组

#### 03. 数组中重复的数字
[题目详情](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

> 找出数组中重复的数字。
> 
> 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

- 思路一：哈希
  
  我首先想到的解法是哈希，因为题目中只要求找出任意一个重复的数字，那么我只要用哈希表插入，查找第一次频数为2的数即可。如果需要找出所有重复的数字，时间复杂度是`O(n)`，但是代价是空间复杂度为`O(n)`的哈希表。

- 思路二：排序
  
  第二个想法是排序，我们能够知道所有的数字都是0~n-1范围内，那么经过排序，只要比较前后两个数字是否重复，就能找出重复的数字，这个方法的时间复杂度是O(nlogn)。

- 思路三：排序+哈希
  
  ```cpp
  class Solution {
    public:
        int findRepeatNumber(vector<int>& nums) {
            int i = 0;
            int ans;
            while(i<nums.size()){
                if(nums[i]==i){
                    i++;
                    continue;
                }else{
                    int m = nums[i];
                    if(nums[m] == nums[i]){
                        ans = nums[i];
                        break;
                    }else{
                        nums[i] =  nums[m];
                        nums[m] = m;
                    }
                }
            }
            return ans;
        }
    };
  ```
  第三个思路是排序和哈希思想的结合，首先我们知道排序后的数组，如果整个数组中没有重复的数字，那么第i个元素的值应该是i。那么我们可以把排序和查找的过程放在一起，从下标i开始：
  1. 如果a[i]==i，那么这个数字位置是对的，跳过；
  2. 如果a[i]!=i，那么这个数字位置不正确，再找到a[a[i]]：
     1. 如果a[a[i]]==a[i]，那么这个元素出现两次，就是重复的；
     2. 如果a[a[i]]!=a[i]，那么将这两个元素交换，放在正确的位置；

  这样的时间复杂度只需要O(n)，空间复杂度O(1)。 

#### 03变. 不修改数组值找出重复数字

> 在一个长度为 n+1 的数组 nums 里的所有数字都在 1～n 的范围内。所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但是不能修改输入的数组。

- 思路一：再造数组
  
  第一个很容易想到的思路是，重新构造一个长度为n+1的数组，将输入数组
- 思路二：