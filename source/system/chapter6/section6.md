## 6.6 死锁预防

死锁避免本质上不可能，因此实际的系统完全是通过破坏死锁的四个条件来预防死锁。

### 6.6.1 破坏互斥条件

首先考虑破坏互斥使用条件，如果资源不被一个进程独占，那么死锁肯定不会发生。但是如果两个进程同时使用某些非抢占式资源，就会造成混乱。

解决方案是：采用**假脱机技术**。该技术允许多个进程同时产生输出，但是唯一真正请求资源的是假托机管理进程，而该进程不会请求别的资源，因此不会因为这个非抢占式资源而产生死锁。

但是这种方式并不能完全预防死锁，以打印机为例。守护进程设计成再完整的输出文件就绪后才开始打印，但是若两个进程分别占用了可用假脱机磁盘空间的一半，而两个进程都缺少另一半，结果会在磁盘上出现死锁。

### 6.6.2 破坏占有并等待条件

其次考虑破坏占有并等待条件，需要禁止已经持有资源的进程再等待其他资源便可以消除死锁。

一种可行的实现方法是，规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，就分配，否则就等待。

但是该方法在实现上几乎不可能，因为很多进程直到运行时才直到它需要多少资源。

还有一种实现方法，当一个进程请求资源时，先暂时释放当前占有的资源，在尝试一次获得所需要的全部资源。

### 6.6.3 破坏不可抢占条件

接下来考虑破坏不可抢占条件，我们可以通过虚拟化技术来实现对某些资源的抢占模拟。例如，假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机。和破坏第一个条件一样，可能会产生磁盘死锁。

### 6.6.4 破坏循环等待条件

最后考虑破坏循环等待条件，一种避免出现环路等待的方法就是将所有资源统一编号，确定资源请求的规则是：进程可以提出资源请求，但是所有请求必须按照资源编号的顺序提出，否则不允许。

该方案虽然可行，但是关键在于找不到使得每个人都满意的资源编号次序，并且资源太多，编号数目会非常大。

### 6.6.5 总结

- 互斥：假脱机技术
- 占有和等待：在开始就请求全部资源
- 不可抢占：虚拟化抢占资源
- 循环等待：对资源按序编号