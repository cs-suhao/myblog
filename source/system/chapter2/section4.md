## 2.4 调度
在多道程序设计系统中，如果多个进程处于就绪态，且只有一个CPU可用，这时候就需要**调度程序**决定哪一个进程可以运行，而该程序使用的算法称为**调度算法**。

### 2.4.1 调度简介

在早期以磁带上的卡片作为输入的批处理系统时代，调度算法仅仅是依次运行磁带上的每一个作业。对于多道程序设计系统，调度算法会复杂一些，因为经常有多个用户等候服务。

个人计算机的出现让情形向两个方向发展：多数时间内只有一个活动进程，以及现在CPU资源不是稀缺资源。因此调度算法在个人PC上不是那么重要。

但是在网络服务器中，调度算法很重要。因为多个进程经常竞争CPU，同时用户的体验会由于调度算法的不同而不同。

另外，调度程序还需要考虑CPU的利用率，因为进程切换的代价是比较高的。首先用户态必须切换到内核态，然后保存当前进程的状态；接着运行调度算法选定另一个进程，之后将新进程的内存映像装入MMU，会消耗大量CPU时间。

#### 2.4.1.1 进程行为

所有进程的I/O请求和计算都是交替突发的。一般而言，CPU不停顿的运行一段时间，然后发出一个系统调用来读写文件，在完成系统调用以后，CPU又开始计算。当然，这里有些I/O活动是可以看成是计算的。

在这样的情况下，有些进程花费绝大多数时间在计算上，有些在绝大多数时间在I/O上。前者称为**计算密集型**，后者称为**I/O密集型**。

随着CPU越来越快，更多的进程倾向于I/O密集型。这是因为CPU的改进比磁盘改进快的多。

#### 2.4.1.2 何时调度

由于存在需要调度处理的各种情形，所以在何时进程调度决策很重要，一般有以下集中情况：
1. 在创建新进程之后，需要决定运行父进程还是子进程。
2. 在一个进程退出时，需要从就绪进程集中选择某一个进程。
3. 当一个进程阻塞在I/O或信号量上时，需要选择另一个进程。
4. 当一个I/O中断发生时。

#### 2.4.1.3 调度算法分类

1. 批处理
2. 交互式
3. 实时

#### 2.4.1.4 调度算法的目标

在不同环境下，调度算法的目标是不一样的：

1. 所有系统
   - 公平：给每个进程公平的CPU份额
   - 策略强制执行：保证规定的策略被执行
   - 平衡：保持系统的所有部分忙碌
2. 批处理系统
   - 吞吐量：每小时最大作业数
   - 周转时间：从提交到终止间的最小时间
   - CPU利用率：保持系统的所有部分忙碌
3. 交互式系统
   - 响应时间：快速响应请求
   - 均衡性：满足用户期望
4. 实时系统
   - 满足截止时间
   - 可预测性


### 2.4.2 批处理系统中的调度

#### 2.4.2.1 先来先服务

在所有调度算法中，最简单的是非抢占式的**先来先服务**(first-come first-served)。进程按照它们请求CPU的顺序使用CPU，当第一个作业从外部进入系统，就立即开始并允许运行它所期望的时间长度，该作业不会因为运行时间太长而被中断。当其他作业进入时，它们会排到就绪队列的尾部。当正在运行的进程被阻塞，就绪队列中的第一个进程会接着运行。而在被阻塞进程变成就绪时，会像新来到的作业一样排在就绪队列的末尾。

算法的主要优点在于易于理解并且便于实现，而缺点在于，如果一个有大量I/O操作的进程需要运行，会重复等待，导致该进程的运行时间非常长。

#### 2.4.2.2 最短作业优先

该算法适用于运行时间可以预知的非抢占式的批处理调度算法。当输入队列中有若干个同等重要的作业被启动时，调度程序应该使用**最短作业优先算法**。

假设A、B、C、D四个作业的时间分别是8、4、4、4分钟。若按照原来顺序执行，A的周转时间是8分钟，B为12分钟(8+4)，C为16分钟(8+4+4)，D为20分钟(8+4+4+4)。按照最短作业优先的原则，A的周转时间20分钟(4+4+4+8)，B为4分钟(4)，C为8分钟(4+4)，D为12分钟(4+4+4)。

所以这样一来，每个作业的平均周转时间就是最小的。**同时需要指出，在所有作业都可以同时运行的情况下，最短作业优先算法才是最优化的。**

可以思考这个例子：
> 考虑5个作业，从A到E，运行时间分别是2、4、1、1、1，它们的到达时间是0、0、3、3、3，按照最短作业优先算法，平均等待时间是多少？

#### 2.4.2.3 最短剩余时间优先

**最短剩余时间优先算法**是最短作业优先的抢占式版本，使用该算法，调度程序总是选择剩余时间最短的进程运行，当一个新作业到达，其整个时间同当前进程的剩余时间做比较，如果新的进程时间更少，当前进程就会被挂起，运行新的进程。

### 2.4.3 交互式系统中的调度

#### 2.4.3.1 轮转调度

一种最古老、简单、公平的算法是**轮转调度**。每个进程被分配一个时间段，称为时间片，允许该进程在该时间段内运行。如果时间片结束时该进程该在运行，则剥夺CPU并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则CPU立即切换。

该算法的关键在于，时间片设置的大小。进程切换也称为上下文切换，是有时间消耗的。假设进程切换需要1ms，而时间片是4ms，这样CPU时间的20%是消耗在管理上，显然很不划算。

但是如果我们将时间片设置成100ms，又会产生，例如同时到达50个请求，第二个进程会在100ms后才启动，依次类推，最后一个进程必须等待5秒。

因此通常时间片设置为20ms~50ms。

#### 2.4.3.2 优先级调度

轮转调度有一个隐含假设，就是所有的进程同等重要。而在多用户的计算机系统中，不同用户的进程优先级是不一致的。因此**优先级调度**的思想很简单，每个进程被赋予一个优先级，允许优先级高的可运行进程先运行。

同时为了防止高优先级进程无休止地运行，调度程序可能在每个时钟中断降低当前进程的优先级；另一种方法是，每一个进程赋予一个最大时间片，当时间片用完，次高优先级的进程便获得运行机会。

并且，优先级可以是静态赋予也可以是动态赋予。

#### 2.4.3.3 多级队列

设立优先级类，属于高优先级类的进程运行1个时间片，属于次高优先级的进程运行2个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，将会被移动到下一类。

![](../image/chapter2/2.4.3.3.png)

#### 2.4.3.4 最短进程优先

在批处理系统中，最短作业优先基本等同于最短响应时间，因此如果把该策略用于交互进程，会非常不错。

因为交互进程遵循：等待命令、执行命令、等待命令、执行命令……这样的循环模式，如果将每一条命令的执行看成一个独立的作业，我们就可以通过最短作业优先来使响应时间最短。

交互式进程的问题在于，如何从当前可运行进程中找出最短的进程。有一种方法是根据进程过去的运行时间预测。并且侧重于当前测量的时间，有滑动平均的思想在里面。

#### 2.4.3.5 保证调度

这是一种向用户作出明确性能保证，然后实现的调度算法。若用户工作时有n个用户登陆，则用户获得CPU处理能力的1/n，类似地，在一个有n个进程运行的单用户系统中，若所有的进程都等价，则每个进程获得1/n的CPU时间。

为了实现所作的保证，系统需要跟踪各个进程创建以来已经使用了多少的CPU时间。然后计算各个进程应该获得的CPU时间，即自创建以来的时间除以n。

例如，计算真正获得的CPU时间和应获得的CPU时间之比。比例为0.5说明一个进程只获得了应得到时间的一半，比例为2.0说明一个进程获得了应得到时间的2倍。于是该算法转向比例最低的进程，直到该进程的比例不是最小。

#### 2.4.3.6 彩票调度

保证调度的思想很好，但是很难实现。因此有一个既可以给出类似预测结果又非常简单的实现算法，称为彩票调度。

基本思想是为进程提供各种系统资源的彩票，一旦需要作出一项调度决策，就随机抽取一张彩票，拥有彩票的进程获得资源。在CPU调度中，系统可以掌握每秒50次的彩票，作为奖励每个获奖者可以得到20ms的CPU时间。

但是该算法的提出者有一句话“所有进程是平等的，但是某些进程更平等一些”，例如可以给更重要的进程额外的彩票，这样就可以增加该进程中将的比例。

该算法的性质如下：
1. 彩票调度的反应是迅速的：因为当新进程出现并得到彩票，其被调度的概率会和它持有的彩票数量是成比例的。
2. 如果希望协作进程可以交换它们的彩票，例如客户端进程向服务器发送消息后就被阻塞，该客户端进程可以把它的彩票交给服务器，就能达到这样的效果。

#### 2.4.3.7 公平分享调度

上述调度算法的讨论，都假设被调度的是各个进程本身，不关注其所有者。现在假设有这样一个场景：用户1启动了9个进程，而用户2启动了1个进程，那么如果使用轮转或相同优先级调度算法，用户1获得CPU的时间会比用户2多得多。

因此为了避免这样的情况，某些系统在调度之前考虑谁拥有这一进程。同时，这只是公平分享调度的一个应用场景，具体还得看公平的定义是什么。

### 2.4.4 实时系统中的调度

实时系统是一种时间起主导作用的系统，当一种或多种外部物理设备发给计算机一个服务请求，计算机必须在一个确定的时间范围内恰当地做出反应。

实时系统可以非为硬实时和软实时。前者是必须满足绝对的截止时间，后者是虽然不希望偶尔错失截止时间，但是可以容忍。并且，只有进程共同需要的CPU时间小于CPU能提供的总时间，同时事件是周期性的，该实时系统才是能够调度的。

### 2.4.5 策略和机制

以上所设计的所有调度算法，都是由内核自己定义并运行。当我们将调度机制和调度策略分离，也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。

这样，尽管父进程本身不参与调度，但是通过参数可以调用内核控制调度子进程的细节。

### 2.4.6 线程调度

线程调度和进程调度是两个层次的并行，并且其中的差异在于操作系统支持的是用户级线程还是内核级线程。

#### 2.4.6.1 用户级线程

用户级线程的实现，对于操作系统来说，其调度的只有进程，当操作系统把CPU时间分配给进程以后，由进程的运行时系统决定调度进程中的哪一个线程。

#### 2.4.6.2 内核级线程

操作系统可以直接调度线程，可以考虑该线程所属进程的情况，也可以不考虑这种情况。
（书中图2-44b有错误）