## 2.3 进程间通信

进程间的通信主要有三个问题：
1. 一个进程如何把消息传递给另一个进程
2. 两个或更多的进程如何确保在关键活动不会出现交叉（例如定座位票）
3. 进程间如何保证运行的顺序

需要注意的是，这几个问题同样适用于线程。

### 2.3.1 竞争条件

**竞争条件**在多核增长的并行环境非常常见，由于多个进程的协作可能会共享一些彼此都能读写的公用存储区。竞争条件指的是：**两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序**。

例如进程A修改变量a令其+1，进程B也需要修改变量a令其+1，如果A先执行，得到的结果是2，B得到的是3.而如果A和B时序变换，得到的结果会产生变化。这就是一种竞争条件。

### 2.3.2 临界区

如何避免竞争条件？关键在于找出某种途径来组织多个进程同时读写共享的数据。我们把对共享内存进行访问的程序片段称为**临界区域**或**临界区**。

我们需要是的两个进程不能同时处于临界区，就能避免竞争条件。除此之外，还需要满足以下4个条件：
1. 任何两个进程不能同时处于其临界区。
2. 不应该对CPU的速度和数量做任何假设。
3. 临界区外运行的进程不得阻塞其他进程。
4. 不得使进程无期限等待进入临界区。

### 2.3.3 忙等待的互斥

现有的几种实现互斥的方案如下：

#### 2.3.3.1 屏蔽中断

在单处理系统中，最简单的方法是使每个进程刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。在屏蔽中断后，时钟中断也会被屏蔽，因为CPU只有发生时钟中断或其他中断才会进行进程切换。

但是这个方案并不好，因为把屏蔽中断的权力交给用户进程是不明智的。有可能一个进程屏蔽中断以后不再打开，会造成系统的终止。并且，如果多处理器中，只屏蔽单个CPU，其他CPU一样可以对共享变量进行访问。

#### 2.3.3.2 锁变量

第二种尝试是软件解决方法，设想有一个共享变量(锁)，初始值为0。当一个进程进入临界区，首先测试这把锁，如果该锁的值为0，则该进程将其设置为1并进入临界区。如果这把锁的值为1，则该进程等待直到锁的值编程0。

但是这种方法仍然有漏洞，假设一个进程读出锁变量的值为0，而恰好在其将锁置为1前，另一个进程被调度执行，将锁置为1。之后第一个进程也会将锁置为1，并且此时有两个进程同时进入临界区。

#### 2.3.3.3 严格轮转法

第三种尝试代码如下：
```c
// Process A
while(1){
    while(turn!=0);
    critical_region();
    turn = 1;
    noncritical_region();
}

// Process B
while(1){
    while(turn!=1);
    critical_region();
    turn = 0;
    noncritical_region();
}
```

这里的`turn`变量用于记录轮到哪一个进程进入临界区。开始时，进程0检查turn，发现turn的值为0，进程0进入临界区。进程1发现turn值不为1，因此一直等待。

连续测试一个变量直到某个值出现为止，称为**忙等待**。由于这种方式浪费CPU事件，所以通常认为等待时间非常短的情况下，才使用忙等待，而用于忙等待的锁称为**自旋锁**。

但是会出现这样的情况：进程0执行完整个循环，会将turn置为1，而进程1虽然退出临界区，但是没有完成整个非临界区的任务，因此没有将turn置为0。也就是说，进程0比进程1快，进程0都执行两轮了，进程1一轮还没有完成。

这时就会导致，进程0开始新一轮的循环时，需要等待进程1完成非临界区程序，因此违反了第三个条件，这个方案也不够好。

#### 2.3.3.4 Peterson解法

T. Dekker通过将锁变量于警告变量的思想结合，提出了一个不需要严格轮换的互斥算法。

### 2.3.4 睡眠与唤醒

### 2.3.5 信号量

### 2.3.6 互斥量

### 2.3.7 管程

### 2.3.8 消息传递

### 2.3.9 屏障

### 2.3.10 避免锁：读-复制-更新

