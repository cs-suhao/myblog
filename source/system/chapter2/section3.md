## 2.3 进程间通信

进程间的通信主要有三个问题：
1. 一个进程如何把消息传递给另一个进程
2. 两个或更多的进程如何确保在关键活动不会出现交叉（例如定座位票）
3. 进程间如何保证运行的顺序

需要注意的是，这几个问题同样适用于线程。

### 2.3.1 竞争条件

**竞争条件**在多核增长的并行环境非常常见，由于多个进程的协作可能会共享一些彼此都能读写的公用存储区。竞争条件指的是：**两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序**。

例如进程A修改变量a令其+1，进程B也需要修改变量a令其+1，如果A先执行，得到的结果是2，B得到的是3.而如果A和B时序变换，得到的结果会产生变化。这就是一种竞争条件。

### 2.3.2 临界区

如何避免竞争条件？关键在于找出某种途径来组织多个进程同时读写共享的数据。我们把对共享内存进行访问的程序片段称为**临界区域**或**临界区**。

我们需要是的两个进程不能同时处于临界区，就能避免竞争条件。除此之外，还需要满足以下4个条件：
1. 任何两个进程不能同时处于其临界区。
2. 不应该对CPU的速度和数量做任何假设。
3. 临界区外运行的进程不得阻塞其他进程。
4. 不得使进程无期限等待进入临界区。

### 2.3.3 忙等待的互斥

现有的几种实现互斥的方案如下：

#### 2.3.3.1 屏蔽中断

在单处理系统中，最简单的方法是使每个进程刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。在屏蔽中断后，时钟中断也会被屏蔽，因为CPU只有发生时钟中断或其他中断才会进行进程切换。

但是这个方案并不好，因为把屏蔽中断的权力交给用户进程是不明智的。有可能一个进程屏蔽中断以后不再打开，会造成系统的终止。并且，如果多处理器中，只屏蔽单个CPU，其他CPU一样可以对共享变量进行访问。

#### 2.3.3.2 锁变量

第二种尝试是软件解决方法，设想有一个共享变量(锁)，初始值为0。当一个进程进入临界区，首先测试这把锁，如果该锁的值为0，则该进程将其设置为1并进入临界区。如果这把锁的值为1，则该进程等待直到锁的值编程0。

但是这种方法仍然有漏洞，假设一个进程读出锁变量的值为0，而恰好在其将锁置为1前，另一个进程被调度执行，将锁置为1。之后第一个进程也会将锁置为1，并且此时有两个进程同时进入临界区。

#### 2.3.3.3 严格轮转法

第三种尝试代码如下：
```c
// Process A
while(1){
    while(turn!=0);
    critical_region();
    turn = 1;
    noncritical_region();
}

// Process B
while(1){
    while(turn!=1);
    critical_region();
    turn = 0;
    noncritical_region();
}
```

这里的`turn`变量用于记录轮到哪一个进程进入临界区。开始时，进程0检查turn，发现turn的值为0，进程0进入临界区。进程1发现turn值不为1，因此一直等待。

连续测试一个变量直到某个值出现为止，称为**忙等待**。由于这种方式浪费CPU事件，所以通常认为等待时间非常短的情况下，才使用忙等待，而用于忙等待的锁称为**自旋锁**。

但是会出现这样的情况：进程0执行完整个循环，会将turn置为1，而进程1虽然退出临界区，但是没有完成整个非临界区的任务，因此没有将turn置为0。也就是说，进程0比进程1快，进程0都执行两轮了，进程1一轮还没有完成。

这时就会导致，进程0开始新一轮的循环时，需要等待进程1完成非临界区程序，因此违反了第三个条件，这个方案也不够好。

#### 2.3.3.4 Peterson解法

Peterson是一种简单的多的护持算法，代码如下：
```c
#define FALSE 0
#define TRUE  1
#define N     2

int turn;
int interested[N];

void enter_region(int process){
    int other;
    other = 1-process;
    interested[process] = TRUE;
    turn = process;
    while(turn == process && interested[other] == TRUE);
}

void leave_region(int process){
    interested[process] = FALSE;
}

```

在进入临界区前，各个进程使用其进程号0或1作为参数调用`enter_region`，该调用在需要时将使进程等待。即使两个进程同时调用`enter_region`，也会因为`turn`变量被重写导致只有一个进程可以进入，另一个进程会因为满足while的循环条件一直等待。

#### 2.3.3.5 TSL指令

这是一种需要硬件支持的方案。某些计算机中，特别是哪些设计为多处理器的计算机，都有下面一条指令：`TSL RX, LOCK`。称为**测试并加锁**(test ans set lock)，它将一个内存字lock读到寄存器RX中，然后在该内存地址上有一个非零值。读和写的操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行TSL指令的CPU将锁住内存总线，防止其他CPU在本指令结束前访问。


### 2.3.4 睡眠与唤醒

Peterson解法和TSL解法都是正确的，但是有忙等待的缺点，两个方案的本质都是：当一个进程想进入临界区，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。

但是这两个方案除了浪费CPU资源外，还会产生其他错误。考虑到两个优先级不同的进程L和进程H，调度规则规定只要H处于就绪态就可以运行，但是某一时刻L处于临界区，H准备运行。但是由于H处于忙等待，而L又不会被调度，那么H将会一直等待下去，会产生**优先级反转问题**。

有一些进程间通信原语，可以在无法进入临界区时阻塞，而不是忙等待。分别是`sleep`和`wakeup`。

#### 2.3.4.1 生产者-消费者问题

我们考虑**生产者-消费者问题**，也称为**有界缓冲区问题**。两个进程共享一个公共的固定大小的缓冲区，其中一个是生产者，将信息放入缓冲区，另一个是消费者，从缓冲区中取出信息。

含有严重竞争条件的生产者-消费者问题代码如下：

```c
#define N 100
int count = 0;

void producer(){
    init item;
    while(TRUE){
        item = produce_item();
        if(count == N) sleep();
        insert_item(item);
        count = count + 1;
        if(count == 1) wakeup(consumer);
    }
}

void consumer(){
    init item;
    while(TRUE){
        if(count == 0) sleep();
        item = remove_item();
        count = count - 1;
        if(count == N-1) wakeup(producer);
        consume_item(item);
    }
}

```

如果我们在消费者刚刚读取`count`值就调度生产者，生产者使用`wakeup`但是消费者并没有真正睡眠，等调度回消费者，消费者开始睡眠，会导致消费者再也醒不过来。

### 2.3.5 信号量

信号量使用一个整型变量累积唤醒次数，取值可以为0(表示没有保存下来的唤醒操作)或者为正值(表示有一个或多个唤醒操作)。对于信号量有两种操作:
- `up`
- `down`

对信号量执行`down`操作，检查其值是否大于0，若大于0则减1(用掉一个保存的唤醒信号)并继续，若该值为0，则将进程睡眠，并且此时down操作并没有结束。

对信号量执行`up`操作，对信号量的值加1。如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则由系统选择其中一个并允许改进成完成down操作。


**值注意的是，这两个操作都是原子操作，也就是说检查数值、修改变量以及可能发生的睡眠操作都是不可分割的**。

#### 2.3.5.1 用信号量解决生产者-消费者问题

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer(){
    init item;
    while(TRUE){
        item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer(){
    init item;
    while(TRUE){
        down(&full);
        down(&mutex);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}

```

1. `mutex`信号量的作用是保证只有一个进程可以进入临界区
2. `empty`和`full`信号量的作用是实现同步，保证当缓冲区满的时候生产者停止运行，以及当缓冲区空的时候消费者停止运行。

### 2.3.6 互斥量

如果不需要信号量的计数能力，可以使用信号量的简化版本——**互斥量**。互斥量仅适用于管理共享资源或一小段代码。

互斥量是一个可以处于两态之一的变量：解锁和加锁。当一个进程/线程需要访问临界区，调用`mutex_lock`，如果该互斥量当前是解锁的，即临界区可用，则调用成功。另一方面，如果该互斥量已经被加锁，调用线程被阻塞，直到临界区中的线程完成并调用`mutex_unlock`。

`mutex_lock`和TSL指令中的`enter_region`很像，但是不一样在于：enter_region进入临界区失败后，会进入忙等待，在内核态中，这个进程会由于时间片用完，调度其他进程运行，可以让拥有锁的进程运行并释放锁。
而如果在用户态中，进程不会释放CPU资源，因此有锁的进程无法运行也就无法释放锁，没有锁的进程又一直在忙等待，不会退出。

所以`mutex_lock`避免了忙等待，在该线程/进程下次运行时，再一次对锁进行测试。

#### 2.3.6.1 futex

#### 2.3.6.2 pthread中的互斥量

### 2.3.7 管程

### 2.3.8 消息传递

### 2.3.9 屏障

### 2.3.10 避免锁：读-复制-更新

