## 3.4 页面置换算法
当发生缺页中断，操作系统必须在内存中选择一个页面将其换出内存，因此需要页面置换算法来决定置换哪一个页面。

同时需要注意的是，页面置换问题还会发生在例如高速缓存中、Web服务器的缓存中。

### 3.4.1 最优页面置换算法

最好的页面置换算法应该是这样：在缺页中断发生时，我们可以知道该页面在多少条指令后被访问，最优页面置换算法就是将置换标记最大的页面，即：页面A在800条指令后才会被使用，页面B则在200条指令后会被使用，那么肯定是置换页面A。

这个算法唯一的问题在与无法实现，因为我们无法预测各个页面下一次将在什么时候被访问。

该算法提出的目的是用于比较其他算法的性能，该算法只存在理论中，只能用于仿真。

### 3.4.2 最近未使用页面置换算法

大部分具有虚拟内存的计算机中，系统为每一个页面设置两个状态位，当页面被访问时置R位，页面被修改置M位，并且这种更新是由硬件实现的，一旦设置某位为1，就会一直保持直到操作系统将其复位。

我们可以使用R位和M位构造一个简单的页面置换算法：当启动一个进程，它的所有页面的两个位都设置成0，R被定期清零。当发生缺页中断，操作系统检查所有页面，并根据R/M位分成四类：
1. 类0：无访问，无修改
2. 类1：无访问，被修改
3. 类2：被访问，无修改
4. 类3：被访问，被修改

算法会从类编号最小的非空类随机挑选一个页面淘汰。该算法的开销比较小，虽然性能不是最好的，但是够用。


### 3.4.3 先进先出页面置换算法

操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的放在表头。当发生缺页中断，淘汰表头的页面，并将新调入的页面加到表尾。

该算法的问题在于，可能会淘汰常用的页面。

### 3.4.4 第二次机会页面置换算法

该算法是对FIFO算法的简单改进，针对了FIFO可能会淘汰常用页面的问题。该算法检查最老页面的R位，如果R位是0，则该页面又老又没用，直接替换；而如果R位是1，则将R清零，并把该页面防盗表尾。

### 3.4.5 时钟页面置换算法

![](../image/chapter3/3.4.5.1.png)

### 3.4.6 最近最少使用页面置换算法

### 3.4.7 软件模拟LRU

### 3.4.8 工作集页面置换算法

### 3.4.9 工作集时钟页面置换算法


### 3.4.10 总结